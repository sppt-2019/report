\chapter*{Preface\markboth{Acknowledgements}{Acknowledgements}}\label{ch:preface}
\addcontentsline{toc}{chapter}{Preface}
The field of game development is subject to many opinions from the industry and is often backed by little scientific evidence. We will therefore need to cite pages that are not \dquote{traditionally scientific} in this report, examples of which are Quora and StackOverflow. These sources are of questionable quality and need not reflect the broad opinion on the game development industry. However, we include them here to indicate that \dquote{some} game developers share the expressed belief.

\section*{Resume}
In this project we examined the claims of two game development gurus: John Carmack and Tim Sweeney. These claims suggested that increased use of functional programming in game development would be beneficial. These potential benefits of functional languages were examined. Tim Sweeney directly suggested two features; explicit effects typing and lenient evaluation strategy. The performance impact of these language features were examined as well as other related boons, such as \gsl{FRP}, implicit parallelism and other concurrency benefits.

We examined if their point-of-view was shared by game development professionals in Aalborg, by conducting a usability evaluation, where the participants were tasked with implementing gameplay code in \fs. The test consisted of gameplay programming tasks inspired by game development. The developers were asked to implement solutions to these tasks in \fs and \cs. We found that the programmers were reluctant to adopt \fs because they believed that the cost of learning a new language would out-weigh the benefits it could provide.

In need of a stronger incentive to promote \fs we decided to examine if \fs could provide more performant concurrent code than \cs. We found that \fs introduces a performance penalty compared to \cs, which is especially noticeable as problem sizes grow. Furthermore, the Async Workflows concurrency strategy employed by \fs seems to be fragile, in the sense that small differences can severely impact performance (using \m{Async.StartChild} instead of \m{Async.Parallel})\tmcc{Isn't it the other way around?}. In comparison, the Task model employed in \cs seems more robust and also results in more performant concurrent code. The same results were obtained when benchmarking \fs in Unity, where \ttt{MonoBehaviour}s implemented in \fs wed a little less performant than those in \cs. The performance of our \gls{FRP} system was worse, which was caused by a simple and suboptimal implementation, where each \ttt{FRPBehaviour} is in fact a full-blown \gls{FRP} system. However, the \gls{FRP} and Async Workflows were well understood by the participants during the test.
