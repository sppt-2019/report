\chapter{Introduction} \label{chap:introduction}
Game development has been dominated by the object oriented programming paradigm since the advent of game engines\cite{anderson@2011:scripting-classes}, arguably even before that. Game engines have separated hardware and rendering specific problems from the game development and thus enabled the emergence of smaller independent game developers\cite{michael2003indie}. These developers have varying levels of training in modern software disciplines\cite{mcgill2009defining, hewner2010game} which exacerbates the complexities of game development\cite{blow2004game}.

Migration to different programming languages that better accommodate these developers has been undertaken by several commercial game engines\needcite. The Unreal Engine has released the visual programming language Blueprint\cite{unreal:blueprint:intro} to support such developers and reduce game development complexity\needcite. While these languages are promising, this niche may also be filled by functional languages. Proponents of functional languages have, in the past, claimed that functional languages excel under similar conditions\cite{kemerer2009impact, hughes1989functional, hu2015functional}. Therefore such languages are examined in a game development context.  

In a previous semester project, we have investigated the performance impact of managed languages in a game development context\cite{p92018gameplay}. Some game development techniques utilising functional programming were also measured, but these systems were not competitive. Instead we examine the functional programming approaches proposed by influential game developers: John Carmack and Tim Sweeney. Their proposed approaches to functional programming, while striving for the same goal, solve\tmc{Jeg synes ikke 'solve' er det rigtige ord her.} the issue very differently.

\quoteWithCite{No matter what language you work in, programming in a functional style provides benefits. You should do it whenever it is convenient, and you should think hard about the decision when it isn't convenient.}{John Carmack}{gamasutra:c++functional}

John Carmack suggests placing the responsibility on the programmer and underlines that the pure functional programming style should be adhered to whenever possible\cite{gamasutra:c++functional}. This approach is well supported in the multiparadigm programming language C\#, which is predominantly object oriented, but supports various functional constructs, such as lambda expressions\cite{csharp:lambda} and soon pattern matching\cite{csharp:pattern:matching}. Another important aspect of this approach is purity. Games are inherently stateful\needcite, but smaller functions may be side-effect free and effectively become pure. Enforcing this is left to the programmer.

\quoteWithCite{Purely Functional is the right default [...]\\Imperative constructs are vital features that must be exposed through explicit effects-typing constructs [...]\\Lenient evaluation is the right default.}{Tim Sweeney}{theNextMainstreanProgrammingLanguage}

The approach proposed by Tim Sweeney suggests a new game-development oriented and functional-programming language\cite{theNextMainstreanProgrammingLanguage}. Thus responsibility is moved away from the programmer. The suggested language should be pure, but support imperative constructs. Another quirk of the language is the proposed evaluation strategy. Sweeney believes that the language should use the lenient evaluation strategy and use strict/eager evaluation as a compiler optimisation, furthermore lazy evaluation may be made available via explicit constructs to the programmer.

\input{chapters/01-introduction/problem-statement.tex}

\section{Project Scope}
As this project researches the use of functional language in game development, we naturally have to select a game framework or game engine that will act as a host for the experiment. We have suggested using C\# and F\# in the experiment because they run in the same platform and are representative of the gurus' suggestions. There are a couple of game engines that support the .NET platform, including Unity, Godot, MonoGame and CryEngine, among others\cite{p92018gameplay}. We chose Unity in this project, because it is the most popular engine that supports the .NET platform \needcite. In fact all of the mentioned platforms unofficially support F\# programming\cite{godot:fsharp,monogame:fsharp,cryengine:fsharp}.