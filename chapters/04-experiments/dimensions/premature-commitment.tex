\subsubsection{Premature Commitment}
Premature commitment describes how much guess-ahead the programmers has to make when he is programming in a given language. 

In F\# there is a fixed ordering when defining types, that enforces all namebindings (\ttt{let}) to be declared before members. This is similar to the problem of \textit{Commitment to layout} presented in \cite{green1996usability}. Luckily, these declarations may quickly be moved arround in F\# source code by cutting and pasting. This problem is not present in C\#, where the programmer is free to choose any ordering he likes when declaring methods, fields and properties on classes.

In C\# the problem of premature commitment may surface when dealing with class hierarchies. The problem is also present in F\#, as it is also object-oriented, but we argue that C\# is more prone to the class-related problems \tmc{Skal vi have en argumentation her}. The problem of premature commitment arises when a programmer has to implement a base class, without being certain which other classes might inherit therefrom. This introduce guess-work and might result in missing functionality, uneeded class members and potentially the requirement to re-implement the base class. This problem is even more prominent when inheriting from third party code that contains multiple classes, as the programmer might choose to inherit from one class and later discover that he took the wrong and need to re-implement the entire class. The problem is more prominent in Unreal than Unity, as Unreal has multiple different base classes for game objects\needcite, where Unity has one.

Another small-scale issue of premature commitment arises when using F\#'s collection functions (such as \ttt{List.map} or \ttt{Array.reduce}). These functions take as first argument a function and as second the collection to operate on. If they are used without the pipe operator (\ttt{|\textgreater}), the \gls{IDE} will be unable to aid the programmer when he is implementing the function until the second argument has been given. The correct order is thus to write the name of the function, add empty brackets, add the name of the collection and finally implement the function.