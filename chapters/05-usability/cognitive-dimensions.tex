\subsubsection{Cognitive Dimensions}
In this experiment we first and foremost wish to test how well-suited \fsh is in the context of game development. In the side-by-side cognitive dimensions analysis we compare the participants' solutions in \fsh with those in \csh, as they were given test cases from the same category. This allow us to use a well-established vocabulary to discuss whether or not functional programming is suitable for game development.

% Do we need this table? It is part of the Champagne testing, but not really related to side-by-side analysis
% \begin{table}[H]
% 	\alignCenter{
% 	\begin{tabular}{| l | c |}\hline
% 		\multicolumn{2}{|c|}{\textbf{Cognitive Dimensions}} \rowEnd
% 	 	Abstract Gradient & \mns \rowEnd
% 		Closeness of Mapping & \mns \rowEnd
% 		Consistency & \mns \rowEnd
% 		Diffuseness/Terseness & \mns \rowEnd
% 		Error-proneness & \mns \rowEnd
% 		Hard Mental Operations & \mns \rowEnd
% 		Hidden Dependencies & \mns \rowEnd
% 		Premature Commitment & \mn \rowEnd
% 		Progressive Evaluation & \mn \rowEnd
% 		Role-expressiveness & \mn \rowEnd
% 		Secondary Notation and Escape from Formalism & \mn \rowEnd
% 		Viscosity & \rowEnd
% 		Visibility and Juxtaposability & \rowEnd
% 	\end{tabular}}
% 	\caption{Cognitive Dimensions Findings}
% 	\label{tab:cog-dim-findings}
% \end{table}

\subsubsection{Abstract Gradient}
The abstract gradient is measured from abstraction hating, through abstraction tolerant, to abstraction loving. The abstractions measured are the notations ability to group elements and refer to them as a single entity. Most modern textual-programming languages make extensive use of abstraction and functional languages even more so \cite{hudak1989conception}. \fs is a functional-programming language with object-oriented features allowing for extensive abstractions.

On the other hand \cs is an object-oriented language which supports functional features. This means that \cs also supports extensive abstraction. The main difference lies in the fact that \cs is object-oriented programming first and \fs is functional programming first. Functional programming tends to make use of abstraction more frequently then conventional programming, however that does not mean conventional programming does not use abstraction often.

Considering the high level of abstraction in both languages they will both be considered abstraction loving in this report. An important detail is that \fs generally relies on finer grain abstraction and \cs on broader abstraction, they each support the others abstraction level.

\subsubsection{Closeness of Mapping}
The measure of how close to the problem domain a language can get is called the closeness of mapping. In order to solve a real problem, that problem must be expressible in the language and the closer the language the easier it is to express \cite{green1996usability}. Textual programming languages are abstractions over the real problem domain and therefore often does not map directly to the domain.

Both languages have mechanisms to model the problem domain. In object-oriented programming, the world is represented as objects and the objects are abstracted over via classes \cite{kindler2011object}. Functional programming models the problem as behaviour (functions) which are applied to data \cite{hughes1989functional}. The advantage of the object oriented approach is that the object abstraction comes quite close the problem domain.

\quoteWithCite{The object expresses the user's view of reality}{Object Oriented Analysis \& Design}{mathiassen2000object}

This approach is in contrast with the functional paradigme which model reality mathematically. This approach is not as close as the object model, however mathematical modelling of the world is widespread in many different fields of study.\tmcc{Matematik bliver brugt til at alt muligt derfor kender folk til det}

\quoteWithCite{Typically the main function is defined in terms of other functions, which in turn are defined in terms of still more functions, until at the bottom level the functions are language primitives. These functions are much like ordinary mathematical functions [...]}{John Hughes}{hughes1989functional}

The abstraction models of the languages are the tools used by the programmers to model the world. \cs uses a model, which lends itself more to closeness of mapping, but both languages make use of custom types and naming which allow programmers to mold their programs in accordance with the problem domain.

\subsubsection{Consistency}


\subsubsection{Diffuseness/Terseness}


\subsubsection{Error-proneness}


\subsubsection{Hard Mental Operations}


\subsubsection{Hidden Dependencies}


\subsubsection{Premature Commitment}


\subsubsection{Progressive Evaluation}


\subsubsection{Role-expressiveness}


\subsubsection{Secondary Notation and Escape from Formalism}


\subsubsection{Viscosity}


\subsubsection{Visibility and Juxtaposability}
