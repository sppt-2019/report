\section{Test Setup}
The test setup draws inspiration from the Champagne Prototyping method and Discount Method for Language Evaluation. The tasks, prototype and participants were selected according to the former, whereas the use of a cheat-sheet for the participant is inspired by the latter. Contrary to the suggestion of using a text editor in Discount Method for Language Evaluation, we chose to use \glspl{IDE}, as we're testing well established languages. We allowed the users to choose between JetBrain's Rider and Microsoft's Visual Studio, depending on what they're used to.

For each participant one and a half hour was allocated. We expected that actual coding time was roughly one hour, as we conducted a questionnaire before the test to learn about the test participants' experience with Unity and an interview after the test to allow the participant to share their opinion on F\# in Unity, C\# and functional programming. Out of the one hour coding time, we intended to use 20 minutes on C\# and 40 minutes on F\#, as the participants were required to have experience with C\# in Unity and therefore likely would complete the C\# tasks faster.

We also created a document with a two-fold purpose, which was made available online\footnote{\url{https://sppt-2019.github.io/unity-fsharp-introduction/}. Please note that the document is in Danish, as all participants were Danes.} using Github pages. The first purpose of the document was to give the test participants an introduction to F\# in Unity prior to the test and second to act as a cheat-sheet during the test. Similarly, the tasks were also made available online during the test\footnote{\url{https://sppt-2019.github.io/unity-fsharp-introduction/tasks/}. Please note that the document is in Danish, as all participants were Danes.}. We also created a Github repository, in which the test-setups were stored\footnote{\url{https://github.com/sppt-2019/Unity-FSharp}}. The master branch of said repository holds a Unity project with eight scenes, one for each of the test cases. The purpose of this setup was to remove Unity as a factor in the experiment and avoid having the participants spend time setting up scenes. For each of the test participants we created a new branch in the repository, which would allow us to view each of the participants' code in isolation.

During the tests we recorded the screen and audio on the test computer. The files were not transcribed, but whenever we quote one of the participants we refer to transcriptions of larger pieces of dialogue that are listed in \appendixref{user:quotes}. We do so in order to give the reader more context on the quotes and avoid \dquote{plucking} sentences out of their context.

\subsection{Test Cases} \label{sec:usability:test:cases}
We created a total of eight test cases, which fall into four categories; player controller, tree traversal, map-reduce and \dquote{concurrent} update. We list concurrent with double ticks here, as we discovered, during the implementation of a reference solution, that Unity only allows reads and writes to \ttt{GameObject} properties on the main thread. The solutions will therefore not be applicable in Unity.

\begin{labeling}{\quad\quad}
    \item[FPS Controller] The participant is to implement a \gls{FiPS} controller, i.e. a component which can be added to a player character to move it around the world with the WASD-keys and rotate the camera with the mouse.
    \item[3rd Person Controller] This test case is similar to the previous test case, only that the camera must rotate around the player character.
    \item[Talent Tree-Walker] The participant is first asked to implement a data structure that can hold a talent tree. Afterwards the player is given a pre-made talent tree from which the participant must calculate two things. At first a character's bonuses in three attributes should be calculated by summing all talents that are \ttt{Picked} and afterwards the maximum achievable bonus of all attributes by summing all talents.
    \item[Dialogue Tree Traversal] The participant is to first implement a data structure that can hold a dialogue tree. Afterwards the participant must parse a list of dialogue options into a tree using his own data structure. Finally the participant is to find all unique dialogue paths that has a certain outcome.
    \item[Currency - Buy and sell] The participant is presented with three different types of coin. He must first implement code that exchanges a given number of said coins into the minimum number of total coins. Afterwards he should add a function to calculate whether a player can buy a certain item from a vendor and finally implement code that buys the item and updates the player's wallet.
    \item[Armour Graph] In this test case, the participant is given a list of armour equipped on a character. The participant is to implement code that sums the character's bonus in three attributes from the armour. In the second half of the test, we assume that certain pieces of armour can scale the attributes from all other pieces of armour and ask the participant to calculate the scaled attribute bonuses.
    \item[Unit Management (RTS)] The participant is to implement an inverse state machine, in the sense that it's a state machine that holds collections of entities for each state in the state machine. At each \ttt{Update} the state machine should map the corresponding state's update-function onto each collection to create new collections of entities. Finally the participant is asked to implement a \dquote{concurrent} mapping of the update-function.
    \item[Magnetic objects] The participant is to simulate magnetism. He is presented with a list of objects, some of them which are magnetic. All magnetic objects should be attracted to a common center-point at a given speed. In the second half of this task the participant is asked to implement a \dquote{concurrent} version of the simulation.
\end{labeling}

The tasks fall into the categories as follows: the two controller-tasks fall into the player controller category, talent tree and dialogue tree falls into the tree traversal category, currency and armour graph fall into the map-reduce category and the remaining two tasks fall into the \dquote{concurrent} update category.

As we want to explore how suitable Carmack's and Sweeney's approaches are to game development, we have decided to use a fixed ordering of the test categories for each participant. We had initially planned that the participants would be given one of the tasks from the controller category as the first task and distribute the remaining semi-randomly, but discovered after the first actual test that the participants would only have time to solve a single task. We therefore decided that the participants would be given starting tasks from different categories. This ordering allow us to compare each of the participants' the solutions to tasks of the same category, and thus evaluate for each participant whether one language is better suited than the other.

\subsection{Participants}
The participants for this experiment where gathered by sending emails to game studios and other game-related companies in Denmark, asking if their employees were interested in participating in the experiment. The participants were required to have experience with C\# and Unity in the game-development industry. We gathered a total of six participants, two participants with Indie game-development experience, three from a company that creates \gls{AR}/\gls{VR} applications and one who teaches children game development.

For selection criteria we looked for participants that had developed games or had significant experience with C\# in Unity. In addition the participants should not have experience with F\#. The criteria where ranked as follows:
\begin{enumerate}
	\item Game development experience.
	\item Unity \& C\# experience.
	\item No F\# experience.
\end{enumerate}

\subsection{Pilot Test}
We conducted a pilot test with a participant from the Programming Technology specialisation course at Aalborg University in order to get some feedback on the setup. The test participant has experience with Unity from Indie game development and teaching Unity programming to children in the Danish secondary school/advanced level (not to be confused with our test participant, who has a similar job). Contrary to the requirements for the actual test, the pilot test participant had experience with F\# and functional programming in general.

Prior to the pilot test we had assumed that a 50/50 distribution between C\# and F\# would give the most valuable results, as it would not skew the results time-wise. During the pilot test the participant, who had prior experience with F\#, was able to complete three tasks in C\# and two in F\#. We therefore decided to change the distribution to 20 mintues of C\# and 40 minutes of F\#. Apart from that, the participant noted that some of the tasks were hard to understand, mainly because they required the participant to utilise code that was pre-implemented by the authors. We decided to rewrite the tests and insert code snippets with existing classes where-ever the participant would have to use them. Finally, the participant noted that the function-name \ttt{ReactTo}, which is used to bind an event handler to a given event, was odd. He suggested naming it to \ttt{Bind}. We chose to ignore this suggestion, with the argument that the sound of \ttt{ReactTo} has a strong connection with \gls{FRP}, whereas \ttt{Bind} has a stronger connection with conventional functional programming.
