\chapter{User Test}
In this chapter we research usability of functional-style programming in game engines. The tests are formulated based on the Champagne Prototyping methodology (see \secref{champagne}). For this test the Unity game engine was extended, via a plugin to support programming in F\#\cite{fsharp2019plugin}. In addition, a \gls{FRP} module was implemented in F\# for Unity, these two extensions served as the prototype under test. The test cases in the following section were formulated as the experimental tasks. Finally a number of domain experts, in this case experienced Unity developers, were selected as participants. 

The usability test was intended to examine the viability of using functional programming in commercial game engines. Again, we draw on the approaches presented by the game development gurus; Carmack and Sweeney. Carmack's opinion of using functional-style programming whenver convenient is represented by C\#, which has many functional-style constructs. Sweeney's opinion of a pure functional language with explicit effects typing constructs is (somewhat) represented by F\#. F\# is pure by default, but it has the \ttt{mutable} keyword, which allows the programmer to declare mutable variables. These variables are overridden using the \ttt{\textless-} operator, which requires the programmer to explicitly indicate a non-pure action.
 
\section{Test Setup}
The test setup draws inspiration from the Champagne Prototyping method and Discount Method for Language Evaluation. The tasks, prototype and participants were selected according to the former, whereas the use of a cheat-sheet for the participant is inspired by the latter. Contrary to the suggestion of using a text editor in Discount Method for Language Evaluation, we chose to use \glspl{IDE}, as we're testing well established languages. We allowed the users to choose between JetBrain's Rider and Microsoft's Visual Studio, depending on what they're used to.

For each participant one and a half hour wass allocated. We expected that actual coding time was roughly one hour, as we conducted a questionnaire before the test to learn about the test participant's experience with Unity and an interview after the test to allow the participant to share their opinion on F\# in Unity, C\# and functional programming. Out of the one hour coding time, we intended to use 20 minutes on C\# and 40 minutes on F\#, as the participants are required to have experience with C\# in Unity and therefore likely will complete the C\# tasks faster.

We also created a document with a two-fold purpose, which was made available online\footnote{\url{https://sppt-2019.github.io/unity-fsharp-introduction/}. Please note that the document is in Danish, as all participants were Danes.} using Github pages. The first purpose of the document was to give the test participants an introduction to F\# in Unity prior to the test and second to act as a cheat-sheet during the test. Similarly, the tasks were also made available online during the test\footnote{\url{https://sppt-2019.github.io/unity-fsharp-introduction/tasks/}. Please note that the document is in Danish, as all participants were Danes.}. We also created a Github repository, in which the test-setups were stored. The master branch of said repository holds a Unity project with eight scenes, one for each of the test cases. The purpose of this setup is to remove Unity as a factor in the experiment and avoid having the participants spend time setting up scenes. For each of the test participants we created a new branch in the repository, which would allow us to view each of the participants' code in isolation.
 
\subsection{Test Cases}
We created a total of eight test cases, which fall into four categories; player controller, tree traversal, map-reduce and \dquote{concurrent} update. We list concurrent with double ticks here, as we discovered, during the implementation of a reference solution, that Unity only allows reads and writes to \ttt{GameObject} properties on the main thread. The solutions will therefore not be concurrent, but rather have a flavour there of.

\begin{labeling}{\quad\quad}
    \item[FPS Controller] The participant is to implement a \gls{FiPS} controller, i.e. a component which can be added to a player character to move it around the world with the WASD-keys and rotate the in place camera with the mouse.
    \item[3rd Person Controller] Similar to the previous test case, only that the camera must rotate around the player character.
    \item[Talent Tree-Walker] The participant is first asked to implement a data structure that can hold a talent tree. Afterwards the player is given a pre-made talent tree from which the participant must calculate two things. At first a character's bonuses in three attributes should be calculated by summing all talents that are \ttt{Picked} and afterwards the maximum bonus of all attributes by summing all nodes.
    \item[Dialogue Tree Traversal] The participant is to first implement a data structure that can hold a dialogue tree. Afterwards the participant must populate a tree based on a list of dialogue options by parsing it into his own data structure. Finally the participant is to find all unique dialogue paths that has a certain outcome. 
    \item[Currency - Buy and sell] The participant is presented with three different types of coin. He must first implement code that combines said coins into the minimum number of total coins. Afterwards he should add a function to calculate whether a player can buy a certain item from a vendor and finally implement code that buys the item and updates the player's wallet. 
    \item[Armour Graph] In this test case, the participant is given a list of armour equipped on a character. The participant is to implement code that sums the character's bonus in three attributes from the armour. In the second half of the test, we assume that certain pieces of armour provide bonuses to all other pieces of armour and ask the participant to calculate the scaled attribute bonuses.
    \item[Unit Management (RTS)] The participant is to implement an inverse state machine, in the sense that it's a state machine that holds collections of entities for each state in the state machine. At each \ttt{Update} the state machine should map the corresponding state's update-function onto each collection to create new collections of entities. Finally the participant is asked to implement a \dquote{concurrent} mapping of the update-function.
    \item[Magnetic objects] The participant is to simulate magnetism. He is presented with a list of objects, some of them which are magnetic. All magnetic objects should be attracted to a common center-point at a given speed. In the second half of this task the participant is asked to implement a \dquote{concurrent} version of the simulation.
\end{labeling}

The tasks fall into the categories as follows: the two controller-tasks fall into the player controller category, talent tree and dialogue tree falls into the tree traversal category, currency and armour graph fall into the map-reduce category and the remaining two tasks fall into the \dquote{concurrent} update category.

As we want to explore how suitable Carmack's and Sweeney's approaches are to game development, we have decided to use a fixed ordering of the test categories for each participant. The participant will always be given one of the tasks from the controller category as the first task. As we have six test participants, we distribute the remaining three categories, such that two participants start with each of the three. This ordering allow us to compare each of the participants' the solutions to tasks of the same category, and thus evaluate for each participant whether one language is better suited than the other. Furthermore, the controller test case is implemented by all participants, allowing us to compare the different solutions.

\subsection{Participants}
The participants for this experiment where gathered by sending emails to game studios and other game-related companies in Denmark, asking if their employees were interested in participating in the experiment. The participants were required to have experience with C\# and Unity in the game-development industry. We gathered a total of six participants, two participants with Indie game-development experience, three from a company that creates \gls{AR}/\gls{VR} applications and one who teaches children game development.

For selection criteria we looked for potential participants that had developed games, significant experience with Unity and C\#. In addition the participants should not have experience with F\#. The criteria where ranked as follows:
\begin{enumerate}
	\item Game development experience.
	\item Unity \& C\# experience.
	\item No F\# experience.
\end{enumerate}

All participants where asked to estimate their own skill levels in these categories and give a ballpark estimate of how many Unity applications they had developed. The results can be seen in \tableref{participant-scores}.

\begin{table}[H]
\begin{tabular}{| c | r | r | r | r | r |}
	\hline
	\textbf{Participant}&\textbf{C\#}&\textbf{Unity}&\textbf{Game Dev}&\textbf{F\#}&\textbf{Unity Apps} \\ \hline
	1 & 9 & 9 & 5 & 3 & 25 \\ \hline
	2 & 8 & 8 & 7 & 2 & 10 \\ \hline
	3 & 8 & 8 & 2 & 1 & 12 \\ \hline
	4 & 10 & 10 & 8 & 1 & 10 \\ \hline
	5 & & & & & \\ \hline
	6 & & & & & \\ \hline
\end{tabular}
\caption{Participants Self Evaluations}
\label{tab:participant-scores}
\end{table}

\subsection{Parameters}
In this experiment we first and foremost wish to test how well-suited F\# is in the context of game development. There are many parameters to choose from when evaluating what \textit{\dquote{good code}} is, but in this particular experiment we choose writability, readability, modularity and execution speed. The writability parameter is evaluated by examining the participants' reactions during the test and the readability by reading through the code in the subsequent analysis. Modularity is included because functional programming allow the participants to write generalised code to carry out multiple different actions when treating data collections \cite{hughes1989functional}. For instance, in the test cases of this experiment a generalised tree walker could be used in the talents task to both calculate the user's current bonus as well as the maximum achievable bonus. Finally, execution speed is included because of the sentiment among game developers, that functional programming is too slow to even consider \cite{pop:functional:slow, pop:functional:sucks}. By comparing the execution speeds of the solutions in C\# and F\# we can give a more scientific opinion is this discussion.

\subsection{Pilot Test}
We conducted a pilot test with a participant from the Programming Technology specialisation course at Aalborg University in order to get some feedback on the setup. The test participant has experience with Unity from Indie game development and teaching Unity programming to children in the Danish secondary school/advanced level (not to be confused with our test participant, who has a similar job). Contrary to the requirements for the actual test, the pilot test participant had experience with F\# and functional programming in general.

Prior to the pilot test we had assumed that a 50/50 distribution between C\# and F\# would give the most valuable results, as it would not skew the results time-wise. During the pilot test the participant, who had prior experience with F\#, was able to complete three tasks in C\# and two in F\#. We therefore decided to change the distribution to 20 mintues of C\# and 40 minutes of F\#. Apart from that, the participant noted that some of the tasks were hard to understand, mainly because they required the participant to utilise code that was pre-implemented by the authors. We decided to rewrite the tests and insert code snippets with existing classes where-ever the participant would have to use them. Finally, the participant noted that the function-name \ttt{ReactTo}, which is used to bind an event handler to a given event, was odd. He suggested naming it to \ttt{Bind}. We chose to ignore this suggestion, with the argument that the sound of \ttt{ReactTo} has a strong connection with \gls{FRP}, whereas \ttt{Bind} has a stronger connection with conventional functional programming.

\section{Results}

\section{Discussion}

\subsection{Evaluation Parameters}
In this test setup we decided to order the tests cases, such that we were able to compare the C\# and F\# solutions for each test participant. Furthermore, the controller test case was implemented by all participants, which allowed us to compare the results across all of the participants. However, a test setup with six participants and eight test cases does provide limitations. \tmc{Mere omkring vores parametre når vi bliver klogere :)}

\subsection{Generalisability}

\subsection{Garbage Collection in Unity}

\section{Conclusion}