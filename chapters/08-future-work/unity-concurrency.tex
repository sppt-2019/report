\subsection{Unity Concurrency}
The possibility of promising implicit concurrency from using the \gls{FRP} system is indeed appealing. Yampa Arcade has managed to implement a concurrent \gls{FRP} system\cite{courtney2003yampa}. In order for this to be possible we would need to utilise the C\# Job System (which, despite its name, should also work in F\#) or \gls{ECS} in Unity. The former allows programmers to implement concurrent code on \ttt{MonoBehaviour}s, whereas the latter uses \ttt{Entity}s rather than \ttt{MonoBehaviour}s. 

The current implementation implements a \ttt{FRPBehaviour}, which inherits from \ttt{MonoBehaviour}. The C\# Job System therefore presents the smallest required change. If we were to implement concurrency using C\# Job System, we would create a collection for each event type that holds references to the objects that has subscribed to the event along with the handler they subscribed. In each \ttt{Update} those collections will be iterated, in parallel, to check the event conditions and call the associated handlers. There are some engineering challenges still, as Unity requires programmers to manually schedule the jobs and only allows value-types (i.e. \ttt{structs}) to be passed as arguments to a job.

With the coming release of Unity's \gls{ECS}, it would also be interesting to examine how well that pairs with \gls{FRP}. We speculate that they might go well hand-in-hand, as events in \gls{FRP} can be replaced with Systems in \gls{ECS} that are invoked only when certain conditions are met. The events of \gls{FRP} may then be represented as a series of components that are attached to the entities. There are likely many engineering challenges to face when developing such system, and our experience with Unity's \gls{ECS} tells us that it is far from simple to use.