\subsection{FRP Optimisation} \label{sec:fw:frp:optimisation}
The problem with the \gls{FRP} system is that each \ttt{FRPBehaviour} is actually a full-blown \gls{FRP}-system with condition-checking and event-dispatching. The \gls{FRP} system could well be a singleton, as this means that conditions are only checked once.

Solving this problem would require a larger refactoring, as this relates to the Unity lifecycle of \ttt{GameObject}s. First and foremost some Unity methods are required to be tied to the \ttt{GameObject} they belong to. Examples of such methods are \ttt{OnCollisionEnter} and \ttt{OnTriggerExit}. Other methods, such as \ttt{Update} and reacting to keyboard strokes could, on the other hand, be tied to a \ttt{FRPEngine}. In this approach the programmer will register each \ttt{FRPBehaviour} to the set of events he would like to react to along with a condition and a handler.

The problem arises when \ttt{GameObject}s are destroyed and the event handlers must be unsubscribed. We have not added support to remove \ttt{FRPBehaviour}s and their event handlers from the \gls{FRP} system, as the current version \dquote{cleans} up after itself when \ttt{FRPBehaviour}s are destroyed. This is to be understood in the sense that the whole system is deallocated and thus never risks invoking event handlers on objects that have been destroyed. The current approach thus risks invoking event handlers on \ttt{FRPBehaviour}s that have already been destroyed. This raises an exception in Unity and yields an unresponsive game.
\tmc{De sidste to s√¶tninger skal omformuleres. De giver ikke rigtigt mening.}

In order to truly determine whether or not \gls{FRP} comes with a performance penalty, these changes would have to be incorporated.
