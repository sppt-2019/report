\chapter{Concurrency and Programming in C\# and F\#}
As part of researching whether or not functional programming in F\# is suitable for Unity game development we conducted a series of experiments. We first and foremost research whether the lenient evaluation strategy provides the high implicit parallelisability that was promised in \cite{DBLP:journals/cl/Tremblay-parallel}. During this research we found that there is a certain threshold of task-sizes, which must be exceeded before parallelisation has a positive effect on execution time. We attempt to estimate this threshold in \secref{crit:work} using two tests; a busy-wait delay estimation and matrix summation.

As part of the project we implemented a simple \gls{FRP} system in Unity, which was meant to smoothen the transition from C\# to F\#. We had initially decided that this experiment would use either lenient evaluation or Async Workflows under the hood to update \ttt{MonoBehaviour}s concurrently, but discovered too late that Unity uses a custom concurrency strategy called Unity C\# Job System\cite{unity:csharp:job:system}. Unity therefore does not allow \ttt{MonoBehaviour} updates from \ttt{Task}s and Async Workflows\cite{unity:async}. The resulting \gls{FRP} system therefore runs sequentially. We also measure the performance of said system to ascertain whether or not the use of functional programming in Unity results in a performance penalty. 

\input{chapters/05-experiments/benchmarks.tex}
\input{chapters/05-experiments/crit-work.tex}
\input{chapters/05-experiments/performance.tex}
