\chapter{Concurrency and Programming in C\# and F\#}
In the previous section we uncovered that even though experienced gameplay programmers write better code in F\#, they were reluctant to switch. In order to introduce functional gameplay programming in the industry, we therefore need stronger incentive. One such incentive could be implicit (or at least simpler) concurrency. In \cite{DBLP:journals/cl/Tremblay-parallel} the author argues that the lenient evaluation strategy, which was also proposed by Sweeney, provides high implicit parallelisability. This evaluation strategy may be implemented in the \gls{FRP} system that we prototyped during the usability test.

In this section we research how the lenient evaluation strategy compares to classic concurrency strategies. During this research we found that there is a certain threshold of task-sizes, which must be exceeded before concurrency has a positive effect on execution time. We attempt to estimate this threshold in \secref{crit:work} using two tests; a busy-wait delay estimation and matrix summation.

In the final section of this chapter we measure the performance of said system to ascertain whether or not the use of functional programming in Unity results in a performance penalty. 

\input{chapters/05-experiments/benchmarks.tex}
\input{chapters/05-experiments/crit-work.tex}
\input{chapters/05-experiments/performance.tex}
