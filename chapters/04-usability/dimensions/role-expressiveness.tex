\subsubsection{Role-expressiveness}
\paragraph{Unit and Void}
In F\# the last expression in a function body is implicitly returned. In some cases that should not be the case and the function should return \ttt{Unit} (equivalent to C\#'s \ttt{void}). If the last line in the function body is not of type \m{Unit}, programmer must add an additional line containing only \ttt{()}. This confused some of the participants, as they felt that it was unnecessary to explicitly indicate a non-existing return type. One of the participants even asked directly what \ttt{Unit} was and the monitor answered with an explanation. Approximately fifteen minutes later the participant encountered another \ttt{Unit}-type problem and was unable to recover without an additional explanation.

\paragraph{Let Declarations}
Another role-expressiveness problem we encountered was that some participants attempted to \ttt{let} declare multiple bindings without initialising them. Some participants assumed that \ttt{let} declarations without assignment would result in default values (such as \ttt{null} for classes).

\paragraph{Pipe Operators}
A single participant also noted that he found F\#'s pipe operations \textit{\dquote{not nice to read}}. He stated that he would prefer the SQL-like variation of \gls{LINQ} in C\# because it is closer to plain English. The monitor asked if it was related to the names of the functions (\ttt{map} and \ttt{reduce} or \ttt{Select} and \ttt{Aggregate}), to which the participant stated that it was solely related to the way pipe operations were structured.

\paragraph{Bindings and Operators}
In F\# the \ttt{=} symbol is used to denote two different operators; the value-binding operator, and the equality operator. Notably the symbol is not used for rebinding (F\#'s equivalent of assignments), which it is in C\#. A comparison of the two different rebinding/assignment styles can be seen in \lstref{ass-comp}. Rebindings are only allowed on \ttt{mutable} variables, which should be limited to a scope.

\begin{listing}[H]
\begin{minipage}{.45\textwidth}
\begin{minted}{fsharp}
let mutable x = 0
x <- 1
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
\begin{minted}{csharp}
int x = 0;
x = 1;
\end{minted}
\end{minipage}
\caption{Assignment Comparison in F\# (left) and C\# (right).}
\label{lst:ass-comp}
\end{listing}

Furthermore, since \ttt{x = 1} is valid in F\#, no errors were encountered immediately. Instead the program behaved unexpectedly and the participants received a warning, that the value of a boolean expression was being ignored. None of the participants were able to deduce the source of the error without assistance from the monitor. The degree of assistance required ranged from a hint to the monitor explaining the problem so that the test could continue.

Some participants encountered minor errors when declaring variables, because variables are implicitly immutable in F\#. This is the opposite of C\#, where the \ttt{const} keyword is used to explicitly declare a variable immutable. However, once the participants realised this, they had no issue using it.

\paragraph{Types and Type Inference}
Many participants had problems with the type system and type inference. The functions provided in the sample sheet had explicitly typed parameters, which the participants partially mimicked when declaring their own functions. However, participants did not specify function return types nor did they utilise typing of their namebindings. An example of such a function can be seen in \lstref{part-func}.

\begin{listing}[H]
\begin{minted}{fsharp}
[...]
let getTotalWithMod (items:Item list) (attribute:Item->int) (attributeMod:Item->float32) =
[...]
\end{minted}
\caption{Participant function with type annotations on parameters, but not on return type.}
\label{lst:part-func}
\end{listing}

In addition several participants remarked that they preferred strictly typed languages, even though they had encountered several type errors. Some of the participants had Python experience, which may explain this assumption, because Python 3.x annotates function parameters similarly to F\# and Python is dynamically typed.

Another problem faced by the participants were related to class type declarations, where the participants did not realise that the brackets after a type's name could be used to pass constructor arguments.

\paragraph{Function Declarations}
Some participants also expressed frustration with how functions are defined. The issue may stem from a problem with our sample sheet, which did not contain an example of a simple function definition. Plenty of functions were defined, but only ever as part of examples of other language features. Furthermore, functions share the \ttt{let} keyword with name bindings, which contributed to the confusion during the test.
%Some participants also had some problems with lambda expressions. Some users where initially thrown off by the \ttt{fun} keyword, while others where new to the concept.

Several participants struggled with lambda expressions in \fs. Some of these participants expressed that they were not familiar with lambda expressions in \cs either, but even the participants with lambda expression experience from \cs had issues with them in \fs. The difference in syntax can be see in \lstref{lam-exp-syn}.

\begin{listing}[H]
\begin{minipage}{.5\textwidth}
\begin{minted}{csharp}
str => Console.WriteLine(str);
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
\begin{minted}{fsharp}
fun str -> printfn str
\end{minted}
\end{minipage}
\caption{Lambda Expression Syntax, C\# on the left and F\# on the right.}
\label{lst:lam-exp-syn}
\end{listing}