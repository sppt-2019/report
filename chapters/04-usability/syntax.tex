\subsection{Syntax Comparison}\label{sec:syntax}
Test participants encountered problems with various aspects of F\#'s syntax. Such issues are to be expected when programming in a new language. As syntactical errors are not the main focus of this inquiry, we list and discuss them in this section in an attempt to rule them out of the actual analysis.

\subsubsection{Bindings and Operators}
In F\# the \ttt{=} symbol is used to denote two different operators; the value-binding operator, and the equality operator. Notably the symbol is not used for rebinding (F\#'s equivalent of assignments), which it is in C\#. A comparison of the two different rebinding/assignment styles can be seen in \lstref{ass-comp}. Rebindings are only allowed on \ttt{mutable} variables, which should be limited to a scope.

\begin{listing}[H]
\begin{minipage}{.45\textwidth}
\begin{minted}{fsharp}
let mutable x = 0
x <- 1
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
\begin{minted}{csharp}
int x = 0;
x = 1;
\end{minted}
\end{minipage}
\caption{Assignment Comparison in F\# (left) and C\# (right).}
\label{lst:ass-comp}
\end{listing}

Furthermore, since \ttt{x = 1} is valid in F\#, no errors were encountered immediately. Instead the program behaved unexpectedly and the participants received a warning, that the value of a boolean expression was being ignored. None of the participants were able to deduce the source of the error without assistance from the monitor. The degree of assistance required ranged from a hint to the monitor explaining the problem so that the test could continue.

Some participants encountered minor errors incorrectlyhen declaring variables, because variables are implicitly immutable in F\#. This is the opposite of C\#, where the \ttt{const} keyword is used to explicitly declare a variable immutable. However, once the participants realised this, they had no issue using it.

\subsubsection{Scopes and Indentation}
Several of the participants did not connect indentation with scope. This meant that the scoping of variables at times presented a challenge. In most test cases the solutions were implemented in a class. As a consequence improperly indented function bodies incorrectly would work initially because the function body would be part of the class instead of the function. Such incorrectly indented functions may still be called within the scope of the class (see \lstref{scope-prob}).

\begin{listing}[H]
\begin{minted}{fsharp}
type FRP_FPSController() =
    inherit FRPBehaviour()

    member this.Start() =
      this.HandleMoveForward()

    member this.HandleMoveForward() =
    let newPosition = this.transform.position + new Vector3(0.0f, 0.0f, _velocity)
    this.transform.position <- newPosition
\end{minted}
\caption{Incorrect indentation of \m{HandleMoveForward}. A problem is reported when code is added after the function declaration.}
\label{lst:scope-prob}
\end{listing}

In \lstref{scope-prob}, lines 7 and 8 are indented incorrectly, but the code compiles and behaves as expected. The \gls{IDE} gives a warning on both lines, but no errors are thrown until new \ttt{member} functions are defined below \ttt{HandleMoveForward}.

\subsubsection{Types and Type Inference}
Many participants had problems with the type system and type inference. The functions provided in the sample sheet had explicitly typed parameters, which the participants partially mimicked when declaring their own functions. However, participants did not specify function return types nor did they utilise typing of their variables. An example of such a function can be seen in \lstref{part-func}.

\begin{listing}[H]
\begin{minted}{fsharp}
[...]
let getTotalWithMod (items:Item list) (attribute:Item->int) (attributeMod:Item->float32) =
[...]
\end{minted}
\caption{Participant function with type annotations on parameters, but not on return type.}
\label{lst:part-func}
\end{listing}

In addition several participants remarked that they preferred strictly typed languages, even though they had encountered several type errors. Some of the participants had Python experience, which may explain this assumption, because Python 3.x annotates function parameters similarly to F\# and Python is dynamically typed.

\subsubsection{Function Definitions}
In F\# all \ttt{let} functions must be declared before the first \ttt{member} function. An example of this can be seen in \lstref{let-mem-incor}. This caused some initial confusion for participants, but it was quickly overcome. The reason for the strict order was not intuitive for the participants. The difference between the use of \ttt{let} and \ttt{member} is the accessibility of the method or function in question. The \ttt{let} keyword denotes a function in the class instance's scope, effectively a private function. The \ttt{member} keyword denotes an instance function, which is similar to methods in C\#.

\begin{listing}[H]
\begin{minted}{fsharp}
type Candy(price:int) =
  member val Price = price with get
  let discountTuesday = this.Price / 2
\end{minted}
\caption{Incorrect order of function declarations. \m{let} declarations must come before \m{member}s.}
\label{lst:let-mem-incor}
\end{listing}

In addition to the confusion surrounding type definitions, participants also expressed frustration with how functions are defined. The issue may stem from a problem with our sample sheet, which did not contain an example of a simple function definition. Plenty of functions were defined, but only ever as part of examples of other language features. Furthermore, functions share the \ttt{let} keyword with name bindings, which contributed to the confusion during the test.
%Some participants also had some problems with lambda expressions. Some users where initially thrown off by the \ttt{fun} keyword, while others where new to the concept.

Several participants struggled with lambda expressions in \fs. Some of these participants expressed that they were not familiar with lambda expressions in \cs either, but even the participants with lambda expression experience from \cs had issues with them in \fs. The difference in syntax can be see in \lstref{lam-exp-syn}.

\begin{listing}[H]
\begin{minipage}{.5\textwidth}
\begin{minted}{csharp}
str => Console.WriteLine(str);
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
\begin{minted}{fsharp}
fun str -> printfn str
\end{minted}
\end{minipage}
\caption{Lambda Expression Syntax, C\# on the left and F\# on the right.}
\label{lst:lam-exp-syn}
\end{listing}
