\chapter{Discussion}

\section{Unity and Garbage Collection}
Unity recommends careful memory management when writing in C\# and avoiding unnecessary heap allocations \cite{unity:optimisation}. The performance optimisation guidelines \cite{unity:optimisation} lists many common performance bottlenecks for Unity developers. The most notable of those are lack of caching and boxing. Unity provides many method and properties that allow developers to access collections of components, such as \ttt{GameObject.FindObjectsWithTag} and \ttt{Mesh.vertices} \cite{unity:optimisation, unity:heap}. Each of those methods allocate a new array for the objects at every invocation, meaning that the code in \lstref{unity:array:prop} allocates four arrays in every iteration of the loop. This puts a huge burden on the garbage collector and will, according to \cite{unity:heap}, result in notisable performance degredation.

\begin{listing}
    \begin{minted}{csharp}
        for(int i = 0; i < mesh.vertices.Length; i++)
        {
            float x, y, z;
        
            x = mesh.vertices[i].x;
            y = mesh.vertices[i].y;
            z = mesh.vertices[i].z;
        
            DoSomething(x, y, z);
        }
    \end{minted}
    \caption{Common performance bottleneck in Unity \cite{unity:heap}. \ttt{mesh.vertices} should be cached.} \label{lst:unity:array:prop}
\end{listing}

The problem of boxing occurs when a value-type should be used by refrence, for instance when constructing a list of integers or append a float to a string. This generates a small ammount of garbage, which can quickly accumulate, e.g. during list iterations. Furthermore, \cite{unity:optimisation} underlines the importance of avoiding \gls{LINQ}-statements all together, due to the garbage generated under the hood. \cite{unity:heap} recommends avoiding coding styles that requires passing functions as arguments and to completely avoid closures, due to the ammount of garbage generated by said language constructs. 

All these recommendations stand in direct contrast to the common practices employed in the functional programming paradigm \needcite. In functional programming it's typical to map over collections, which has two problems compared to this Unity performance guideline:
\begin{enumerate}
    \item map allocates a new collection in stead of mutating the existing collection.
    \item map requires a function as one of the argument, which defines what should happen to each of the elements in the collection.
\end{enumerate}
This practise also extends to other generalised constructs, such as the tree-walker employed in talents test case. These guidelines explains why Unity Technologies does not want to add F\# support despite the over 3500 votes in April 2018\cite{unity:fsharp}. The vote was later closed by Unity, without any explanation\footnote{We have not been able to find a source for this claim, as Unity has closed their feedback forums.}.

Unity uses the Boehm–Demers–Weiser garbage collector\cite{boehm2007transparent}, which is a conservative mark-sweep garbage collector, originally created for automatic memory management in C and C++. Mark-sweep algorithms are the most basic type of garbage collectors and has the primary disadvantages that they halt computation while running, increase in execution time as more objects are allocated and may fragment memory\cite{spo:gc}. The dotnet runtime uses a generational garbage collector with three generations \cite{dotnet:gc}. The lower generations are collected more often than the higher and all surviving objects are moved to the higher generations. Each time a generation $n | n > 0$ is collected, all lower generations are also collected. Generational garbage collectors have the advantage that short-lived object allocations has a smaller performance penalty, but the disadvantage that they may perform poorly if too many objects reach higher generations. Depending on the platform the dotnet platform may use different garbage collection strategies, including concurrent versions \cite{dotnet:gc}. Concurrent garbage collectors can collect garbage concurenly with the computation, meaning that garbage collection pauses are minimised or entirely removed \cite{dotnet:gc}.

% Unity's garbage collector: https://en.wikipedia.org/wiki/Boehm_garbage_collector
% IL2CPP: https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/

\section{Unity and Parallelisation}