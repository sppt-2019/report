\section{Technology Choices}
In this section we discuss the choices of technology for the project. We first discuss the choice of Unity as the host game engine for the experiment. Afterwards we discuss the choice of C\# and F\# as languages in this experiment.

\subsection{Game Engine}
In this project we chose to use the game engine Unity. We had three reasons for this choice; Unity is popular, it supports the .NET runtime and we have prior experience with it. We argued that any engine that supports the .NET runtime, such as Godot, CryEngine and MonoGame, would have been a viable choices. Furthermore, we prefabricated code, scenes and assets that the programmers were to use during the tests. The goal of said prefabricated code was to rule out the game engine as a factor in the experiments and merely turn it into a \dquote{play button}.
We therefore argue that game engine would have been viable choices, albeit some would require more setup than others. Take for example Unreal Engine, which has a virtual machine for running Blueprints\cite{unreal2019blueprintNativiziation}. This virtual machine could probably also host a functional language. However, it would require a new language to be built as none are readily available.

Unity is source-available for customers with the \dquote{Pro} subscription plan. This means that the engine and editor may only be adapted with the tool Unity Technologies provide (i.e. writing custom inspectors and editor plugins with C\#). This puts a natural cap on how \dquote{far} custom implementations may diverge from Unity's implementation. A better, but also more time consuming approach would be to use the open source game engine Godot. Godot has support for GDScript and Mono, among others. We speculate that this could mean that new languages may be introduced with relative ease.

\subsection{Programming Languages}
