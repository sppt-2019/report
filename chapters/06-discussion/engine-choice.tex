\section{Technology Choices}
In this section we discuss the choices of technology for the project. We first discuss the choice of Unity as the host game engine for the experiment. Afterwards we discuss the choice of C\# and F\# as languages in this experiment.

\subsection{Game Engine}
In this project we chose to use the game engine Unity. We had three reasons for this choice; Unity is popular, it supports the .NET runtime and we have prior experience with it. We argued that any engine that supports the .NET runtime, such as Godot, CryEngine and MonoGame, would have been a viable choices. Furthermore, we prefabricated code, scenes and assets that the programmers were to use during the tests. The goal of said prefabricated code was to rule out the game engine as a factor in the experiments and merely turn it into a \dquote{play button}.
We therefore argue that game engine would have been viable choices, albeit some would require more setup than others. Take for example Unreal Engine, which has a virtual machine for running Blueprints\cite{unreal2019blueprintNativiziation}. This virtual machine could probably also host a functional language. However, it would require a new language to be built as none are readily available.

Unity is source-available for customers with the \dquote{Pro} subscription plan. This means that the engine and editor may only be adapted with the tool Unity Technologies provide (i.e. writing custom inspectors and editor plugins with C\#). This puts a natural cap on how \dquote{far} custom implementations may diverge from Unity's implementation. A better, but also more time consuming approach would be to use the open source game engine Godot. Godot has support for GDScript and Mono, among others. We speculate that this could mean that new languages may be introduced with relative ease.

\subsection{Programming Languages}
We chose to use C\# and F\# in this experiment. This choice was mainly out of convenience because those two languages share the .NET runtime. The choice is associated with a potential source of error, namely that both languages are multi-paradigm. This means that C\# programmers may in fact write fully functional programs and vice versa. In practice we saw fairly limited use of functional code in C\# and more use of imperative code in F\#. We suspect that this is a matter of habit, more than it is a matter of the stateful nature of games. The reason is that the participants are most likely used to a certain problem-solving strategy when they program, which has its center in the imperative paradigm. 

The shared runtime is also worth discussing. We experienced that some of the participants were unsure of why one would use F\# instead of C\# because all the classes are called the same. This is a consequence of the shared runtime. We thought that the well-known classes would result in a smoother transition and a sense of familiarity, but it seems that the known classes and the way of expressing functionality in some cases was indistinguishable for our participants. With that in mind, it may have provided more useful information if we had used an entirely other game engine for the functional part. On the other hand, this may introduce yet another learning factor in form of a completely new environment.