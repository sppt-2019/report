\section{Methodology}
In this section we will discuss the chosen methodology for this project. A number of different methodologies were presented in \secref{prog-usability}, of these we opted for \champagne. None of the methodologies were exact matches for our case, causing us to modify \champagne to fit our case better. This modification consisted of including additional \attentions and \cognitive usability methodologies.

\subsection{Champagne Prototyping}
The \champagne method was selected because of its cheap deployment cost and the availability of a \fs plugin for \unity\cite{fsharp2019plugin}. This meant that early in the project the necessities of the method were met (see \secref{champagne}), i.e. a fully operational prototype based on an existing product. However, \discount was also an option. This methodology only requires a set of problems and some participants to solve them. The use of an \gls{IDE} is optional, as the methodology is intended to test languages before a compiler has been implemented. This means that it is an ideal fit for evaluating programming languages. \champagne uses a scenario-based task formulation strategy, which we argue is better suited for testing user interfaces. We therefore decided to draw inspiration from the tasks formulations in \discount and apply them with the participant selection and analysis of \champagne. We chose the analysis of \champagne for two reasons:
\begin{enumerate}
    \item \discount uses \gls{IDA}, which was simply not possible for us due to planning issues.
    \item \cognitive and \attention, which are used by \champagne, are better suited for evaluating programming languages than \gls{IDA}.
\end{enumerate}

A third alternative is \expert. However, as the name implies, this method requires an expert in each language under test. In addition, participants would be required to participate in multiple sessions. This was a concern, as finding qualified participants willing to spend an hour on the test already proposed a challenge. Given this challenge, \champagne was the method which provided the most benefit at the smallest cost. This freed up time to improve the test setup and explore features such as the \gls{FRP} system.

\subsubsection{Attention Investment Model}
The primary contribution of the \attention in this project is the overview of participant comprehension. This can be seen in \tabref{comp-matrix}, where an overview of what the participants understood of the \gls{FRP} system. The method was used as a broad-brush measure to participant comprehension, however it can be used as a finer grain tool. When used in this way, the method could be used to simulate participant behaviour and thus explain their decision making process\cite{blackwell2002first}. This approach was not used due to the significant effort required. In addition, it was not obvious from the paper how to apply the method in practice.

Furthermore, the \attention method was designed to map the decisions made by the programmer during a programming activity. In particular, the method may be used to explore when and why a programmer decides to generalize an implementation, instead of hard coding it. However, in \champagne it is targeted at a certain feature. We used to methodology in accordance with \champagne and in a similar manner to \cognitive; as a vocabulary to discuss the decision-making  process of the participants (see \secref{att-inv-app}).
\tmc{Jeg forstår overhovedet ikke den sidste sætning her...}

\subsubsection{Multipass Cognitive Dimensions}
The \cognitive framework is used in \champagne, but we also used the framework on its own. The reason for this was to discuss our experience with \fs and \cs separately from the participants' experience. This allowed us to compare the experiences and make educated guesses on whether some issues are resolved with more practice. This means that \cognitive was applied twice, first as vocabulary to compare \cs and \fs, and second as part of \champagne to gain an overview of usability issues. The first application was in the same style as our previous study of gameplay programming languages\cite{p92018gameplay}.

The main difference we observed between the two passes was that the participants only sparsely talked about paradigms. The participants had a tendency of associating all their problems with the new syntax, rather than the new way of thinking.
Furthermore, we saw very little use of the function abstraction we discussed under the abstraction gradient dimension (see \secref{our-abstract-gradient}). Instead, the participants would attempt to use the object-orientation of F\# to implement gameplay code like they were used to. We also observed that a participant did not want to add types in his F\# code, because he argued that it would clash with the functional paradigm. Regarding consistency, we observed that the participants experienced many of the same issues as we did, particularly related to lists, type compatibility and function signatures. Many participants struggled with F\#'s type inference, which we chose to classify as role-expressiveness. The reason for this was that some participants thought they were dealing with a dynamic type system, and we thus argue that F\#'s type system does not sufficiently express that it is, in fact, strongly typed. This was an unexpected discovery, as we knew in advance that F\# has a strong type system with inference.
%Role-expressiveness: type inference
%Syntax vs. semantics
