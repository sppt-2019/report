\section{Performance Difference of F\# and C\#}\label{sec:perf-diff}
In the benchmarks undertaken in this project, \fs has consistently been out performed by \cs. This section discuss this performance difference and it's significance. In addition, the parallelisation strategies, in both languages, are compared.

The benchmarks where structured to test the potential performance speed-up of using lenient evaluation strategy for implicit parallelisation (see \secref{benchmarks}). Therefore the first benchmarks compare a sequential implementation (as a control), an \fs strategy (Async Workflows), a \cs strategy (Tasks) and the lenient evaluation strategy. We found that the sequential control outperformed the parallel implementations in all cases (see \secref{bench-res}). This prompted the next benchmark, where we examined the growth of the strategies (see \secref{crit:work}). However, the Task based and the lenient strategies performed comparably, while the Async Workflows grew very fast. In these benchmarks \fs performed slower than \cs, but not by much.

Given the surprising results in the first round of benchmarks, we hypothesised that the cause was the problem size. In order to tests this hypothesis another round of benchmarks where constructed (see \secref{crit:work}). These tested the strategies with an arbitrary workload that was gradually increased until the parallel strategies outperformed the sequential strategy. The workload was implemented as a pair of \m{for} loops iterating a number of times (see \secref{crit-work-setup} and \lstref{benchmark:strategies-helper}). The results indicated that our hypothesis was correct and that the parallel strategies scaled better than the sequential strategy(see \secref{crit-work-res} and \secref{crit-work-matrix-res}).

Finally, a round of benchmarking was conducting inside the \unity engine. The focus of these benchmarks was to ascertain, if \fs caused a significant performance penalty in this environment. According to \unity's performance guidelines\cite{normark2008mapping, unity:fsharp} garbage generation will severely impact performance and \fs generates more performance than \cs (see \secref{func-garbage}). The findings indicates that \fs scales worse than \cs depending on the employed strategy (see \secref{unity-garbage-res}, \tabref{unity:ai} and \figref{ai:benchmark}). However, this issue is largely dependent on \unity's use of an outdated \gls{GC} strategy (see \secref{gc-strat}) and could therefore be solved by switching to modern \gls{GC}.

Outside of \unity, \fs has a small impact on performance, however the additional garbage has a severe impact on performance in \unity. However, this performance problem in \unity can be solved by modernising the \gls{GC}. Therefore we can conclude that the performance is not significant for most cases. This is supported by a concurrent study which found that \fs was 7\% slower than \cs\cite{bolhuis2019gameplay} and another study which found a 5\% difference\cite{maggiore2012formal}.
