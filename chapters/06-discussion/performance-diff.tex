\section{Performance Difference of F\# and C\#}\label{sec:perf-diff}
In the benchmarks undertaken in this project, \fs has consistently been out performed by \cs. This section discuss this performance difference and it's significance. In addition, the parallelisation strategies, in both languages, are compared.

The benchmarks were structured to test the potential performance speed-up of using lenient evaluation strategy for implicit parallelisation (see \secref{benchmarks}). Therefore the first benchmarks compare a sequential implementation (as a control), an \fs strategy (Async Workflows), a \cs strategy (Tasks) and the lenient evaluation strategy. We found that the sequential control outperformed the concurrent implementations in all cases (see \secref{bench-res}). This prompted the next benchmark, where we examined the growth of the strategies (see \secref{crit:work}). However, the Task based and the lenient strategies performed comparably, while the execution times of Async Workflows grew very fast as the number of nodes increase. In these benchmarks \fs was marginally slower than \cs.

Given the surprising results in the first round of benchmarks, we hypothesised that the cause was the problem size. In order to tests this hypothesis another round of benchmarks were constructed (see \secref{crit:work}). These tested the strategies with an arbitrary workload that was gradually decreased until the sequential strategies outperformed the concurrent ones. The workload was implemented as a pair of \m{for} loops iterating a given number of times (see \secref{crit-work-setup} and \lstref{benchmark:strategies-helper}). The results indicated that our hypothesis was correct and that the parallel strategies scaled better than the sequential strategy(see \secref{crit-work-res} and \secref{crit-work-matrix-res}).

Finally, a round of benchmarking was conducted inside the \unity engine. The focus of these benchmarks was to ascertain if \fs caused a significant performance penalty in this environment. According to \unity's performance guidelines garbage generation will severely impact performance and \fs generates more performance\tmc{garbage?} than \cs (see \secref{func-garbage})\cite{normark2008mapping, unity:fsharp}. The findings indicates that \fs scales worse than \cs, depending on the employed strategy (see \secref{unity-garbage-res}, \tabref{unity:ai} and \figref{ai:benchmark}). However, this issue is largely dependent on \unity's use of an outdated \gls{GC} strategy (see \secref{gc-strat}) and could therefore be solved by switching to modern \gls{GC} algorithms.

Outside of \unity, \fs has a small impact on performance, however the additional garbage has a larger impact on performance in \unity. However, this performance problem in \unity can be solved by modernising the \gls{GC}. Therefore we can conclude that the performance is not significant for most cases. This is supported by another study, which found that \fs was 7\% slower than \cs\cite{bolhuis2019gameplay} and another study which found a 5\% difference\cite{maggiore2012formal}. 

\tmc{Forslag til tilf√∏jelse}Furthermore, the consensus of the participants in the usability evaluation seemed to be that productivity was more important than performance. This further underlines that it is no longer technical limitations that hinder the use of functional programming in game development. These arguments break a long tradition in game development, where performance have been the most important factor. We must speculate whether the participants of this study are not developing AAA games that push the limit of computational power, which could be one of the reasons why they're less concerned than tradition says.
